package main

import (
	"flag"
	"github.com/catalystsquad/app-utils-go/logging"
	"github.com/catalystsquad/go-proto-gql/pkg/protoparser"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/types/pluginpb"
	"log"
	"os"
	"path"
	"path/filepath"
	"strings"

	"github.com/catalystsquad/go-proto-gql/pkg/generator"
	"github.com/vektah/gqlparser/v2/formatter"
)

type arrayFlags []string

func (i *arrayFlags) String() string {
	return "str list"
}

func (i *arrayFlags) Set(value string) error {
	*i = append(*i, value)
	return nil
}

var (
	importPaths   = arrayFlags{}
	fileNames     = arrayFlags{}
	ignoreProtos  = arrayFlags{}
	svc           = flag.Bool("svc", false, "Use service annotations for nodes corresponding to a GRPC call")
	merge         = flag.Bool("merge", false, "Merge all the proto files found in one directory into one graphql file")
	extension     = flag.String("ext", generator.DefaultExtension, "Extension of the graphql file, Default: '.graphql'")
	useFieldNames = flag.Bool("useFieldNames", false, "By default graphql field names are generated by converting the proto field name to camelCase. Set this option to true to use the raw protobuf field name as the graphql field name")
	useBigIntType = flag.Bool("useBigIntType", false, "When set to true, will output BigInt instead of Int for int64 proto types. This is helpful for javascript graphql implementations, see https://www.npmjs.com/package/apollo-type-bigint")
)

func main() {
	flag.Var(&importPaths, "I", "path")
	flag.Var(&fileNames, "f", "path")
	flag.Var(&ignoreProtos, "ignoreProtos", "fully qualified protobuf names to ignore, for example 'google.protobuf.Value' separated by spaces")
	flag.Parse()
	descs, err := protoparser.Parse(importPaths, fileNames)
	fatal(err)
	p, err := protogen.Options{}.New(&pluginpb.CodeGeneratorRequest{
		FileToGenerate: fileNames,
		ProtoFile:      generator.ResolveProtoFilesRecursively(descs).AsFileDescriptorProto(),
	})
	fatal(err)
	logging.Log.WithField("ignoreProtos", ignoreProtos).Info("main")
	gqlDesc, err := generator.NewSchemas(descs, *merge, *svc, *useFieldNames, *useBigIntType, ignoreProtos, p)
	fatal(err)
	for _, schema := range gqlDesc {
		if len(schema.FileDescriptors) < 1 {
			log.Fatalf("unexpected number of proto descriptors: %d for gql schema", len(schema.FileDescriptors))
		}
		if len(schema.FileDescriptors) > 1 {
			err := generateFile(schema, true)
			fatal(err)
			break
		}
		err := generateFile(schema, *merge)
		fatal(err)
	}
}

func fatal(err error) {
	if err != nil {
		log.Fatal(err)
	}
}

func generateFile(schema *generator.SchemaDescriptor, merge bool) error {
	sc, err := os.Create(resolveGraphqlFilename(schema.FileDescriptors[0].GetName(), merge, *extension))
	if err != nil {
		return err
	}
	defer sc.Close()

	formatter.NewFormatter(sc).FormatSchema(schema.AsGraphql())
	return nil
}

func resolveGraphqlFilename(protoFileName string, merge bool, extension string) string {
	if merge {
		gqlFileName := "schema." + extension
		absProtoFileName, err := filepath.Abs(protoFileName)
		if err == nil {
			protoDirSlice := strings.Split(filepath.Dir(absProtoFileName), string(filepath.Separator))
			if len(protoDirSlice) > 0 {
				gqlFileName = protoDirSlice[len(protoDirSlice)-1] + "." + extension
			}
		}
		protoDir, _ := path.Split(protoFileName)
		return path.Join(protoDir, gqlFileName)
	}

	return strings.TrimSuffix(protoFileName, path.Ext(protoFileName)) + "." + extension
}
